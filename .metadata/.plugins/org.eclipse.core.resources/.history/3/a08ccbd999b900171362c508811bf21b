package ie.gmit.sw;

import java.awt.List;
import java.util.*;

public class TypeA {
	
	public static void main(String[] args) throws Throwable {
		
		System.runFinalizersOnExit(true);
		TypeB b = new TypeB(new Date());
		TypeC tc = new TypeC(new TypeB(new Date()).getDate()); //One way to do this with constructor
		
		
		for (int i = 0; i < 100; i ++){
			tc.add(new TypeD("G" + i));
		}
		
		System.out.println("Count: " + tc.count());
		
		TypeD td = new TypeD("G50");
		boolean result = tc.remove(td); //Proves that full encapsulation works.
		
		System.out.println("Remove returned " + result + ". There are " + tc.count() + " elements in container.");
		
		List<TypeD> tds = tc.elements(); //The List returned by elements() is a copy containing clones
		tds.clear(); //Clears the copy and the clones, but leaves the integrity of TypeC intact

		
		System.out.println("Count: " + tc.count()); //Proof: there are still 99 elements in TypeC
		
		
		/*
		TypeD d = new TypeD("giggity");
		c.add(new TypeD("hello"));
		
		c.add(new TypeD("hello2"));
		
		c.count();
		
		d.setName("giggity2");
		c.add(d);
		System.out.println(c.elements().toString());
		System.out.println(c.contains(d));
		c.delete(d);
		System.out.println(c.contains(d));
		
		*/
		
	}

}
